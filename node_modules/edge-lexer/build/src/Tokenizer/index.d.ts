/**
 * edge-lexer
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
import { Scanner } from '../Scanner';
import { Tags, Token, RuntimeTag, RuntimeComment, RuntimeMustache, LexerTagDefinitionContract } from '../Contracts';
/**
 * Tokenizer converts a bunch of text into an array of tokens. Later
 * these tokens can be used to build the transformed text.
 *
 * Go through the README file to learn more about the syntax and
 * the tokens output.
 */
export declare class Tokenizer {
    private template;
    private tagsDef;
    private options;
    tokens: Token[];
    /**
     * Holds the current tag statement, until it is closed
     */
    tagStatement: null | {
        scanner: Scanner;
        tag: RuntimeTag;
    };
    /**
     * Holds the current mustache statement, until it is closed
     */
    mustacheStatement: null | {
        scanner: Scanner;
        mustache: RuntimeMustache | RuntimeComment;
    };
    /**
     * Current line number
     */
    private line;
    /**
     * Tracking if two back to back lines are tags or not. Need it for inserting
     * whitespace between them
     */
    private isLastLineATag;
    /**
     * When true, the tokenizer will drop the newline
     */
    private dropNewLine;
    /**
     * An array of opened block level tags
     */
    private openedTags;
    constructor(template: string, tagsDef: Tags, options: {
        filename: string;
        onLine?: (line: string) => string;
        claimTag?: (name: string) => LexerTagDefinitionContract | null;
    });
    /**
     * Returns the raw token
     */
    private getRawNode;
    /**
     * Returns the new line token
     */
    private getNewLineNode;
    /**
     * Returns the TagToken for a runtime tag. The `jsArg` and ending
     * loc is computed using the scanner and must be passed to this
     * method.
     */
    private getTagNode;
    /**
     * Consume the runtime tag node.
     *
     * If tag is `block`, then we push it to the list of
     * opened tags and wait for the closing statement to
     * appear.
     *
     * Otherwise, we move it to the tokens array directly.
     */
    private consumeTag;
    /**
     * Handles the opening of the tag.
     */
    private handleTagOpening;
    /**
     * Scans the string using the scanner and waits for the
     * closing brace ')' to appear
     */
    private feedCharsToCurrentTag;
    /**
     * Returns the mustache type by checking for `safe` and `escaped`
     * properties.
     */
    private getMustacheType;
    /**
     * Returns the mustache token using the runtime mustache node. The `jsArg` and
     * ending `loc` is fetched using the scanner.
     */
    private getMustacheNode;
    /**
     * Returns the comment token using the runtime comment node.
     */
    private getCommentNode;
    /**
     * Handles the line which has mustache opening braces.
     */
    private handleMustacheOpening;
    /**
     * Feed chars to the mustache statement, which isn't closed yet.
     */
    private feedCharsToCurrentMustache;
    /**
     * Returns a boolean telling if the content of the line is the
     * closing tag for the most recently opened tag.
     *
     * The opening and closing has to be in a order, otherwise the
     * compiler will get mad.
     */
    private isClosingTag;
    /**
     * Consume any type of token by moving it to the correct list. If there are
     * opened tags, then the token becomes part of the tag children. Otherwise
     * moved as top level token.
     */
    private consumeNode;
    /**
     * Pushes a new line to the list. This method avoids
     * new lines at position 0.
     */
    private pushNewLine;
    /**
     * Process the current line based upon what it is. What it is?
     * That's the job of this method to find out.
     */
    private processText;
    /**
     * Checks for errors after the tokenizer completes it's work, so that we
     * can find broken statements or unclosed tags.
     */
    private checkForErrors;
    /**
     * Parse the template and generate an AST out of it
     */
    parse(): void;
}
